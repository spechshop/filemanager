#!/usr/bin/env php
<?php
/**
 * Sistema Avan√ßado de Backup e Gerenciamento de Servi√ßos
 * Uso: php backup.php [comando] [op√ß√µes]
 *
 * Funcionalidades:
 * - Backup versionado com timestamps
 * - Gerenciamento de crons/servi√ßos
 * - Limpeza autom√°tica de backups antigos
 * - Backup incremental
 * - Logs detalhados
 */

class AdvancedBackupManager
{
    private string $currentDir;
    private string $baseBackupDir;
    private array $config;
    private string $logFile;
    public array $services;

    public function __construct()
    {
        $this->currentDir = getcwd();

        // Salvar backups em pasta externa ao projeto
        $projectName = basename($this->currentDir);
        $parentDir = dirname($this->currentDir);
        $this->baseBackupDir = $parentDir . '/backups_' . $projectName;

        // Log tamb√©m fica fora do projeto
        $this->logFile = $this->baseBackupDir . '/backup.log';

        $this->loadConfig();
        $this->initializeServices();

        // Criar diret√≥rio de backup se n√£o existir
        $this->createBackupDirectory($this->baseBackupDir);
    }

    private function loadConfig(): void
    {
        // Config tamb√©m fica fora do projeto para n√£o ser perdido
        $configFile = $this->baseBackupDir . '/backup-config.json';

        $defaultConfig = [
                'max_versions' => 10,
                'backup_compression' => true,
                'incremental_backup' => true,
                'exclude_patterns' => ['.tmp', '.log', '.cache'],
                'files_to_backup' => [
                        'database.json',
                        'trunks.json',
                        'plugins/configInterface.json',
                        'manage/plugins/configInterface.json',
                        'manage/database/storage.sqlite3',
                        'manage/database/storage.sqlite3-shm',
                        'manage/database/storage.sqlite3-wal',
                        'manage/database/schema.sql',
                        'liga.php',
                        'server.php',
                        'runnerServer.php',
                        'mediaServer.php',
                        '*.json',
                        '*.php'
                ],
                'auto_cleanup' => true,
                'notifications' => [
                        'enabled' => true,
                        'email' => '',
                        'webhook_url' => ''
                ]
        ];

        if (file_exists($configFile)) {
            $userConfig = json_decode(file_get_contents($configFile), true);
            $this->config = array_merge($defaultConfig, $userConfig);
        } else {
            $this->config = $defaultConfig;
            if (!is_dir($this->baseBackupDir)) {
                mkdir($this->baseBackupDir, 0755, true);
            }
            file_put_contents($configFile, json_encode($defaultConfig, JSON_PRETTY_PRINT));
            $this->log("‚ú® Arquivo de configura√ß√£o criado em: {$configFile}");
        }
    }

    private function initializeServices(): void
    {
        $this->services = [
                'server' => [
                        'name' => 'Servidor Principal',
                        'script' => 'server.php',
                        'port' => 5060,
                        'pid_file' => '/tmp/server.pid',
                        'enabled' => true
                ],
                'manage' => [
                        'name' => 'Servidor WEB',
                        'script' => 'manage/server.php',
                        'pid_file' => '/tmp/manage.pid',
                        'port' => 443,
                        'enabled' => true
                ],
                'media' => [
                        'name' => 'Servidor de M√≠dia',
                        'script' => 'mediaServer.php',
                        'port' => 9503,
                        'pid_file' => '/tmp/media.pid',
                        'enabled' => true
                ]
        ];
    }

    public function save( $version = null): bool
    {
        $timestamp = date('Y-m-d_H-i-s');
        $version = $version ?? $timestamp;
        $versionDir = $this->baseBackupDir . '/v_' . $version;

        echo "üîÑ Iniciando backup versionado (v_{$version})...\n";
        $this->log("Iniciando backup versionado: v_{$version}");

        if (!$this->createBackupDirectory($versionDir)) {
            return false;
        }

        $backedUpFiles = 0;
        $skippedFiles = 0;
        $totalSize = 0;
        $files = $this->resolveFilesToBackup();

        foreach ($files as $file) {
            $sourcePath = $this->currentDir . '/' . $file;

            if (!file_exists($sourcePath)) {
                echo "‚ö†Ô∏è  Arquivo n√£o encontrado: {$file}\n";
                $skippedFiles++;
                continue;
            }

            // Verificar se deve ser exclu√≠do
            if ($this->shouldExcludeFile($file)) {
                echo "üö´ Arquivo exclu√≠do por filtro: {$file}\n";
                $skippedFiles++;
                continue;
            }

            $backupPath = $versionDir . '/' . $file;
            $backupFileDir = dirname($backupPath);

            if (!is_dir($backupFileDir)) {
                mkdir($backupFileDir, 0755, true);
            }

            // Backup incremental: verificar se mudou desde o √∫ltimo backup
            if ($this->config['incremental_backup'] && $this->fileNotChanged($file)) {
                echo "üìÑ Arquivo n√£o alterado (incremental): {$file}\n";
                $this->createSymlink($file, $backupPath);
                $backedUpFiles++;
                continue;
            }

            if (copy($sourcePath, $backupPath)) {
                $fileSize = filesize($backupPath);
                $totalSize += $fileSize;
                $fileSizeKb = round($fileSize / 1024, 2);
                echo "‚úÖ Backup realizado: {$file} ({$fileSizeKb} KB)\n";
                $backedUpFiles++;
            } else {
                echo "‚ùå Erro ao fazer backup de: {$file}\n";
                $this->log("Erro ao fazer backup de: {$file}");
            }
        }

        // Criar arquivo de informa√ß√µes da vers√£o
        $this->createVersionInfo($version, $backedUpFiles, count($files), $skippedFiles, $totalSize);

        // Compress√£o opcional
        if ($this->config['backup_compression']) {
            $this->compressBackup($versionDir);
        }

        // Limpeza autom√°tica
        if ($this->config['auto_cleanup']) {
            $this->cleanupOldBackups();
        }

        $totalSizeMb = round($totalSize / (1024 * 1024), 2);
        echo "\nüéâ Backup v_{$version} conclu√≠do!\n";
        echo "   üìä {$backedUpFiles} arquivos salvos\n";
        echo "   üìÅ {$skippedFiles} arquivos ignorados\n";
        echo "   üíæ Tamanho total: {$totalSizeMb} MB\n";
        echo "   üìÇ Local (EXTERNO): {$versionDir}\n";
        echo "   üõ°Ô∏è  Backup seguro fora do projeto!\n";

        $this->log("Backup conclu√≠do: v_{$version} - {$backedUpFiles} arquivos - {$totalSizeMb} MB");
        $this->sendNotification("Backup conclu√≠do", "Vers√£o: v_{$version}\nArquivos: {$backedUpFiles}\nTamanho: {$totalSizeMb} MB");

        return $backedUpFiles > 0;
    }

    public function restore( $version = null): bool
    {
        if ($version === null) {
            $version = $this->getLatestVersion();
            if (!$version) {
                echo "‚ùå Nenhum backup encontrado!\n";
                return false;
            }
        }

        $versionDir = $this->baseBackupDir . '/v_' . $version;

        if (!is_dir($versionDir)) {
            echo "‚ùå Vers√£o de backup n√£o encontrada: v_{$version}\n";
            return false;
        }

        echo "üîÑ Iniciando restaura√ß√£o da vers√£o v_{$version}...\n";
        $this->log("Iniciando restaura√ß√£o: v_{$version}");

        // Criar backup de seguran√ßa antes da restaura√ß√£o
        $safetyBackup = 'safety_' . date('Y-m-d_H-i-s');
        echo "üõ°Ô∏è  Criando backup de seguran√ßa: v_{$safetyBackup}...\n";
        $this->save($safetyBackup);

        $restoredFiles = 0;
        $files = $this->getFilesFromVersion($versionDir);

        foreach ($files as $file) {
            $backupPath = $versionDir . '/' . $file;
            $targetPath = $this->currentDir . '/' . $file;

            if (!file_exists($backupPath)) {
                continue;
            }

            $targetDir = dirname($targetPath);
            if (!is_dir($targetDir)) {
                mkdir($targetDir, 0755, true);
            }

            if (copy($backupPath, $targetPath)) {
                echo "‚úÖ Restaurado: {$file}\n";
                $restoredFiles++;
            } else {
                echo "‚ùå Erro ao restaurar: {$file}\n";
                $this->log("Erro ao restaurar: {$file}");
            }
        }

        echo "\nüéâ Restaura√ß√£o da v_{$version} conclu√≠da!\n";
        echo "   üìä {$restoredFiles} arquivos restaurados\n";
        echo "   üõ°Ô∏è  Backup de seguran√ßa salvo como: v_{$safetyBackup}\n";

        $this->log("Restaura√ß√£o conclu√≠da: v_{$version} - {$restoredFiles} arquivos");
        $this->sendNotification("Restaura√ß√£o conclu√≠da", "Vers√£o: v_{$version}\nArquivos: {$restoredFiles}");

        return $restoredFiles > 0;
    }

    public function listVersions(): void
    {
        echo "üìã Vers√µes de backup dispon√≠veis:\n\n";

        if (!is_dir($this->baseBackupDir)) {
            echo "‚ùå Nenhum backup encontrado.\n";
            return;
        }

        $versions = $this->getAllVersions();

        if (empty($versions)) {
            echo "‚ùå Nenhuma vers√£o encontrada.\n";
            return;
        }

        foreach ($versions as $version) {
            $versionDir = $this->baseBackupDir . '/v_' . $version;
            $infoFile = $versionDir . '/version_info.json';

            if (file_exists($infoFile)) {
                $info = json_decode(file_get_contents($infoFile), true);
                $sizeMb = round($info['total_size'] / (1024 * 1024), 2);

                echo "üîñ v_{$version}\n";
                echo "   üìÖ Data: {$info['timestamp']}\n";
                echo "   üìä Arquivos: {$info['files_backed_up']}\n";
                echo "   üíæ Tamanho: {$sizeMb} MB\n\n";
            } else {
                echo "üîñ v_{$version} (sem informa√ß√µes detalhadas)\n\n";
            }
        }
    }

    public function deleteVersion(string $version): bool
    {
        $versionDir = $this->baseBackupDir . '/v_' . $version;

        if (!is_dir($versionDir)) {
            echo "‚ùå Vers√£o n√£o encontrada: v_{$version}\n";
            return false;
        }

        echo "üóëÔ∏è  Removendo vers√£o v_{$version}...\n";

        if ($this->removeDirectory($versionDir)) {
            echo "‚úÖ Vers√£o v_{$version} removida com sucesso!\n";
            $this->log("Vers√£o removida: v_{$version}");
            return true;
        } else {
            echo "‚ùå Erro ao remover vers√£o v_{$version}!\n";
            $this->log("Erro ao remover vers√£o: v_{$version}");
            return false;
        }
    }

    // Gerenciamento de servi√ßos/crons
    public function startService(string $serviceName): bool
    {
        if (!isset($this->services[$serviceName])) {
            echo "‚ùå Servi√ßo n√£o encontrado: {$serviceName}\n";
            return false;
        }

        $service = $this->services[$serviceName];

        // Verificar se j√° est√° rodando
        if ($this->isServiceReallyRunning($serviceName)) {
            echo "‚ö†Ô∏è  Servi√ßo {$service['name']} j√° est√° executando!\n";

            // Mostrar informa√ß√µes do processo
            if (isset($service['port']) && $this->isPortInUse($service['port'])) {
                echo "üîå Porta {$service['port']} em uso\n";
            }

            $pids = $this->findProcessesByScript($service['script']);
            if (!empty($pids)) {
                echo "üìç PIDs encontrados: " . implode(', ', $pids) . "\n";
            }

            return true;
        }

        // Verificar se a porta est√° livre (se especificada)
        if (isset($service['port']) && $this->isPortInUse($service['port'])) {
            echo "‚ùå Porta {$service['port']} j√° est√° em uso!\n";
            echo "üí° Use: php backup.php killport {$service['port']} para liberar\n";
            return false;
        }

        // Verificar se o script existe
        if (!file_exists($service['script'])) {
            echo "‚ùå Script n√£o encontrado: {$service['script']}\n";
            return false;
        }

        echo "üöÄ Iniciando servi√ßo: {$service['name']}...\n";

        // Criar diret√≥rio do PID se n√£o existir
        $pidDir = dirname($service['pid_file']);
        if (!is_dir($pidDir)) {
            mkdir($pidDir, 0755, true);
        }

        // Iniciar servi√ßo em background usando screen
        $logFile = "/tmp/{$serviceName}.log";
        $sessionName = "service_{$serviceName}";
        $command = sprintf(
                'cd %s && screen -dmS %s bash -c "php %s > %s 2>&1; exec bash"',
                escapeshellarg($this->currentDir),
                escapeshellarg($sessionName),
                escapeshellarg($service['script']),
                escapeshellarg($logFile)
        );

        shell_exec($command);

        // Obter PID da sess√£o screen e salvar
        sleep(1); // Aguardar screen inicializar
        $screenPidCommand = sprintf('screen -list | grep %s | awk \'{print $1}\' | cut -d. -f1', escapeshellarg($sessionName));
        $screenPid = trim(shell_exec($screenPidCommand));

        if ($screenPid && is_numeric($screenPid)) {
            file_put_contents($service['pid_file'], $screenPid);
        }

        // Aguardar inicializa√ß√£o com timeout
        $timeout = 10;
        $started = false;

        for ($i = 0; $i < $timeout; $i++) {
            sleep(1);

            // Verificar se o processo est√° rodando
            if ($this->isServiceReallyRunning($serviceName)) {
                $started = true;
                break;
            }

            echo "‚è≥ Aguardando inicializa√ß√£o... ({$i}s)\n";
        }

        if ($started) {
            echo "‚úÖ Servi√ßo {$service['name']} iniciado com sucesso!\n";

            // Mostrar informa√ß√µes adicionais
            $pid = $this->getServicePid($serviceName);
            if ($pid) {
                echo "üìç PID: {$pid}\n";
            }

            if (isset($service['port'])) {
                echo "üîå Porta: {$service['port']}\n";
            }

            echo "üìã Log: {$logFile}\n";

            $this->log("Servi√ßo iniciado: {$service['name']} (PID: {$pid})");
            return true;
        } else {
            echo "‚ùå Falha ao iniciar servi√ßo: {$service['name']}\n";

            // Mostrar √∫ltimas linhas do log para diagn√≥stico
            if (file_exists($logFile)) {
                echo "üìã √öltimas linhas do log:\n";
                $logContent = shell_exec("tail -5 {$logFile}");
                echo $logContent . "\n";
            }

            // Limpar arquivo PID se existir
            if (file_exists($service['pid_file'])) {
                unlink($service['pid_file']);
            }

            $this->log("Falha ao iniciar servi√ßo: {$service['name']}");
            return false;
        }
    }

    public function stopService(string $serviceName): bool
    {
        if (!isset($this->services[$serviceName])) {
            echo "‚ùå Servi√ßo n√£o encontrado: {$serviceName}\n";
            return false;
        }

        $service = $this->services[$serviceName];

        echo "üõë Parando servi√ßo: {$service['name']}...\n";

        // M√©todo 1: Tentar parar sess√£o screen se existir
        $sessionName = "service_{$serviceName}";
        $screenList = shell_exec('screen -list');
        $stopped = false;

        if ($screenList && str_contains($screenList, $sessionName)) {
            echo "üì∫ Finalizando sess√£o screen: {$sessionName}\n";

            // Finalizar sess√£o screen (isso mata todos os processos dentro dela)
            $killScreenCommand = sprintf('screen -S %s -X quit', escapeshellarg($sessionName));
            shell_exec($killScreenCommand);

            // Aguardar finaliza√ß√£o
            for ($i = 0; $i < 5; $i++) {
                sleep(1);
                $screenList = shell_exec('screen -list');
                if (!$screenList || !str_contains($screenList, $sessionName)) {
                    echo "‚úÖ Sess√£o screen finalizada\n";
                    $stopped = true;
                    break;
                }
                echo "‚è≥ Aguardando finaliza√ß√£o da sess√£o... ({$i}s)\n";
            }
        }

        // M√©todo 2: Tentar parar via PID se existir
        if (!$stopped) {
            $pid = $this->getServicePid($serviceName);

            if ($pid && posix_kill($pid, 0)) {
                echo "üìç Encontrado PID: {$pid}\n";

                // Tentar SIGTERM primeiro (graceful)
                echo "‚ö†Ô∏è  Enviando SIGTERM para {$pid}...\n";
                posix_kill($pid, SIGTERM);

                // Aguardar at√© 10 segundos para finalizar graciosamente
                for ($i = 0; $i < 10; $i++) {
                    sleep(1);
                    if (!posix_kill($pid, 0)) {
                        echo "‚úÖ Processo finalizado graciosamente\n";
                        $stopped = true;
                        break;
                    }
                    echo "‚è≥ Aguardando finaliza√ß√£o... ({$i}s)\n";
                }

                // Se n√£o parou, usar SIGKILL
                if (!$stopped && posix_kill($pid, 0)) {
                    echo "üíÄ For√ßando finaliza√ß√£o com SIGKILL...\n";
                    posix_kill($pid, SIGKILL);
                    sleep(2);

                    if (!posix_kill($pid, 0)) {
                        echo "‚úÖ Processo for√ßado a parar\n";
                        $stopped = true;
                    }
                }
            }
        }

        // Limpar arquivo PID
        if (file_exists($service['pid_file'])) {
            unlink($service['pid_file']);
        }

        // M√©todo 2: Procurar processos pelo nome do script
        if (!$stopped) {
            echo "üîç Procurando processos pelo nome do script...\n";
            $pids = $this->findProcessesByScript($service['script']);

            foreach ($pids as $foundPid) {
                echo "üìç Processo encontrado: {$foundPid}\n";

                // SIGTERM primeiro
                posix_kill($foundPid, SIGTERM);
                sleep(2);

                // Verificar se parou
                if (!posix_kill($foundPid, 0)) {
                    echo "‚úÖ Processo {$foundPid} finalizado\n";
                    $stopped = true;
                } else {
                    // SIGKILL se necess√°rio
                    echo "üíÄ For√ßando parada do processo {$foundPid}...\n";
                    posix_kill($foundPid, SIGKILL);
                    sleep(1);

                    if (!posix_kill($foundPid, 0)) {
                        echo "‚úÖ Processo {$foundPid} for√ßado a parar\n";
                        $stopped = true;
                    }
                }
            }
        }

        // M√©todo 3: Tentar liberar a porta se especificada
        if (!$stopped && isset($service['port'])) {
            echo "üîå Tentando liberar porta {$service['port']}...\n";
            $portStopped = $this->killPort($service['port']);
            if ($portStopped) {
                $stopped = true;
            }
        }

        // Verifica√ß√£o final
        sleep(1);
        if (!$this->isServiceReallyRunning($serviceName)) {
            echo "‚úÖ Servi√ßo {$service['name']} parado com sucesso!\n";
            $this->log("Servi√ßo parado: {$service['name']}");
            return true;
        } else {
            echo "‚ùå Servi√ßo {$service['name']} ainda est√° executando\n";
            echo "üí° Tente usar: php backup.php killport {$service['port']} ou killall -9 php\n";
            $this->log("Falha ao parar servi√ßo: {$service['name']}");
            return false;
        }
    }

    public function restartService(string $serviceName): bool
    {
        echo "üîÑ Reiniciando servi√ßo: {$serviceName}...\n";
        $this->stopService($serviceName);
        sleep(1);
        return $this->startService($serviceName);
    }

    public function showServicesStatus(): void
    {
        echo "üîß Status dos Servi√ßos:\n\n";

        foreach ($this->services as $name => $service) {
            $isRunning = $this->isServiceReallyRunning($name);
            $status = $isRunning ? "‚úÖ Executando" : "‚ùå Parado";

            echo "üîπ {$service['name']}: {$status}\n";
            echo "   Script: {$service['script']}\n";

            if ($isRunning) {
                // Informa√ß√µes detalhadas quando executando
                $pid = $this->getServicePid($name);
                if ($pid) {
                    echo "   PID: {$pid}\n";

                    // Mostrar uso de CPU/Mem√≥ria se dispon√≠vel
                    $psInfo = shell_exec("ps -p {$pid} -o pid,ppid,pcpu,pmem,etime,cmd --no-headers 2>/dev/null");
                    if ($psInfo) {
                        $psInfo = trim($psInfo);
                        $parts = preg_split('/\s+/', $psInfo, 6);
                        if (count($parts) >= 5) {
                            echo "   CPU: {$parts[2]}% | Mem√≥ria: {$parts[3]}% | Tempo: {$parts[4]}\n";
                        }
                    }
                }

                // Verificar se est√° rodando em sess√£o screen
                $sessionName = "service_{$name}";
                $screenList = shell_exec('screen -list');
                if ($screenList && str_contains($screenList, $sessionName)) {
                    echo "   üì∫ Sess√£o screen: {$sessionName}\n";
                }

                // Verificar porta se especificada
                if (isset($service['port']) && $service['port']) {
                    $portInUse = $this->isPortInUse($service['port']);
                    $portStatus = $portInUse ? "‚úÖ Ativa" : "‚ùå Livre";
                    echo "   Porta {$service['port']}: {$portStatus}\n";
                }

                // Mostrar PIDs encontrados por busca
                $foundPids = $this->findProcessesByScript($service['script']);
                if (count($foundPids) > 1) {
                    echo "   ‚ö†Ô∏è  M√∫ltiplos processos encontrados: " . implode(', ', $foundPids) . "\n";
                } elseif (count($foundPids) === 1 && $foundPids[0] !== $pid) {
                    echo "   ‚ö†Ô∏è  PID do arquivo difere do processo encontrado: {$foundPids[0]}\n";
                }
            } else {
                // Verificar se existe arquivo PID √≥rf√£o
                if (file_exists($service['pid_file'])) {
                    echo "   ‚ö†Ô∏è  Arquivo PID √≥rf√£o detectado\n";
                }

                // Verificar se a porta ainda est√° em uso
                if (isset($service['port']) && $service['port'] && $this->isPortInUse($service['port'])) {
                    echo "   ‚ö†Ô∏è  Porta {$service['port']} ainda em uso por outro processo\n";
                }
            }

            echo "\n";
        }

        // Mostrar processos PHP suspeitos que podem ser nossos servi√ßos
        echo "üîç Verifica√ß√£o de Processos PHP:\n";
        $phpProcesses = shell_exec("ps aux | grep 'php.*\\.php' | grep -v grep | wc -l");
        echo "Total de processos PHP executando: " . trim($phpProcesses) . "\n\n";

        // Listar processos PHP que podem ser relevantes
        $relevantProcesses = shell_exec("ps aux | grep 'php.*\\.php' | grep -v grep | head -5");
        if ($relevantProcesses) {
            echo "Processos PHP ativos (primeiros 5):\n";
            $lines = explode("\n", trim($relevantProcesses));
            foreach ($lines as $line) {
                if (trim($line)) {
                    $parts = preg_split('/\s+/', trim($line));
                    if (count($parts) >= 11) {
                        $pid = $parts[1];
                        $cmd = implode(' ', array_slice($parts, 10));
                        echo "  PID {$pid}: " . substr($cmd, 0, 80) . "\n";
                    }
                }
            }
        }
    }

    public function startAllServices(): void
    {
        echo "üöÄ Iniciando todos os servi√ßos...\n\n";

        foreach (array_keys($this->services) as $serviceName) {
            $this->startService($serviceName);
        }
    }

    public function stopAllServices(): void
    {
        echo "üõë Parando todos os servi√ßos...\n\n";

        foreach (array_keys($this->services) as $serviceName) {
            $this->stopService($serviceName);
        }
    }

    // M√©todos auxiliares
    private function isServiceRunning(string $serviceName): bool
    {
        // Verificar via PID primeiro
        $pid = $this->getServicePid($serviceName);
        if ($pid && posix_kill($pid, 0)) {
            return true;
        }

        // Verificar se realmente est√° rodando procurando pelo script
        return $this->isServiceReallyRunning($serviceName);
    }

    private function isServiceReallyRunning(string $serviceName): bool
    {
        if (!isset($this->services[$serviceName])) {
            return false;
        }

        $service = $this->services[$serviceName];

        // M√©todo 1: Verificar via arquivo PID primeiro (mais confi√°vel)
        $pid = $this->getServicePid($serviceName);
        if ($pid && posix_kill($pid, 0)) {
            // Processo existe, verificar se √© realmente o nosso
            if ($this->isOurProcess($pid, $service['script'])) {
                return true;
            } else {
                // PID file inv√°lido, limpar
                if (file_exists($service['pid_file'])) {
                    unlink($service['pid_file']);
                }
            }
        }

        // M√©todo 2: Verificar sess√£o screen
        $sessionName = "service_{$serviceName}";
        $screenList = shell_exec('screen -list');
        if ($screenList && str_contains($screenList, $sessionName)) {
            // Extrair PID da sess√£o screen se n√£o temos arquivo PID
            if (!file_exists($service['pid_file'])) {
                $screenPidCommand = sprintf('screen -list | grep %s | awk \'{print $1}\' | cut -d. -f1', escapeshellarg($sessionName));
                $screenPid = trim(shell_exec($screenPidCommand));
                if ($screenPid && is_numeric($screenPid)) {
                    file_put_contents($service['pid_file'], $screenPid);
                }
            }
            return true;
        }

        // M√©todo 3: Procurar pelo nome do script (mais restritivo agora)
        $pids = $this->findProcessesByScript($service['script']);
        if (!empty($pids)) {
            // Atualizar arquivo PID com o primeiro processo v√°lido encontrado
            if (!file_exists($service['pid_file'])) {
                file_put_contents($service['pid_file'], $pids[0]);
            }
            return true;
        }

        // M√©todo 3: Verificar se a porta est√° sendo usada (apenas se especificada)
        if (isset($service['port']) && $service['port']) {
            $portInUse = $this->isPortInUse($service['port']);
            if ($portInUse) {
                // Verificar se o processo que usa a porta √© realmente nosso servi√ßo
                $processes = $this->getProcessesUsingPort($service['port']);
                foreach ($processes as $pid) {
                    if ($this->isOurProcess($pid, $service['script'])) {
                        // Atualizar arquivo PID
                        if (!file_exists($service['pid_file'])) {
                            file_put_contents($service['pid_file'], $pid);
                        }
                        return true;
                    }
                }
            }
        }

        return false;
    }

    private function getServicePid(string $serviceName): ?int
    {
        $pidFile = $this->services[$serviceName]['pid_file'];
        if (file_exists($pidFile)) {
            $pid = (int)trim(file_get_contents($pidFile));
            if ($pid > 0 && posix_kill($pid, 0)) {
                return $pid;
            }
            // Arquivo PID inv√°lido, remover
            unlink($pidFile);
        }
        return null;
    }

    public function findProcessesByScript(string $scriptName): array
    {
        $validPids = [];
        $scriptPath = $this->currentDir . '/' . $scriptName;

        // M√©todo 1: Buscar por processos PHP executando o script espec√≠fico
        $command = "ps aux | grep 'php.*" . escapeshellarg($scriptName) . "' | grep -v grep";
        $output = shell_exec($command);

        if ($output) {
            $lines = array_filter(explode("\n", $output));
            foreach ($lines as $line) {
                if (preg_match('/\s+(\d+)\s+/', $line, $matches)) {
                    $pid = (int)$matches[1];

                    // Verificar se √© realmente nosso processo
                    if ($this->isOurProcess($pid, $scriptName)) {
                        $validPids[] = $pid;
                    }
                }
            }
        }

        // M√©todo 2: Buscar especificamente por PHP + nome do arquivo
        if (empty($validPids)) {
            $scriptBasename = basename($scriptName);
            $command = "pgrep -f 'php.*" . escapeshellarg($scriptBasename) . "'";
            $pgrepOutput = shell_exec($command);

            if ($pgrepOutput) {
                $pids = array_filter(array_map('trim', explode("\n", $pgrepOutput)));
                foreach ($pids as $pid) {
                    $pid = (int)$pid;
                    if ($pid > 0 && $this->isOurProcess($pid, $scriptName)) {
                        $validPids[] = $pid;
                    }
                }
            }
        }

        // M√©todo 3: Buscar por sess√µes screen dos servi√ßos
        if (empty($validPids)) {
            foreach ($this->services as $serviceName => $service) {
                if ($service['script'] === $scriptName) {
                    $sessionName = "service_{$serviceName}";
                    $screenCommand = "screen -list | grep " . escapeshellarg($sessionName) . " | awk '{print $1}' | cut -d. -f1";
                    $screenPid = trim(shell_exec($screenCommand)??'');

                    if ($screenPid && is_numeric($screenPid)) {
                        // Verificar se a sess√£o screen realmente existe e est√° rodando nosso script
                        if ($this->isScreenSessionValid($screenPid, $sessionName, $scriptName)) {
                            $validPids[] = (int)$screenPid;
                        }
                    }
                    break;
                }
            }
        }

        return array_unique($validPids);
    }

    public function isOurProcess(int $pid, string $scriptName): bool
    {
        if (!posix_kill($pid, 0)) {
            return false; // Processo n√£o existe
        }

        // Verificar a linha de comando do processo
        $cmdlineFile = "/proc/{$pid}/cmdline";
        if (file_exists($cmdlineFile)) {
            $cmdline = file_get_contents($cmdlineFile);
            $cmdline = str_replace("\0", " ", $cmdline); // Substituir null bytes por espa√ßos

            // Verificar se cont√©m PHP e o nome do script
            if (!stripos($cmdline, 'php')) {
                return false;
            }

            $scriptBasename = basename($scriptName);
            if (!stripos($cmdline, $scriptBasename)) {
                return false;
            }

            // Verificar se n√£o √© um processo de busca (grep, ps, etc.)
            if (stripos($cmdline, 'grep') !== false || 
                stripos($cmdline, 'pgrep') !== false ||
                stripos($cmdline, 'ps ') !== false) {
                return false;
            }
        }

        // Verificar o diret√≥rio de trabalho do processo (se poss√≠vel)
        $cwdFile = "/proc/{$pid}/cwd";
        if (is_link($cwdFile)) {
            $processCwd = readlink($cwdFile);
            // Se o diret√≥rio de trabalho for diferente do nosso, pode n√£o ser nosso processo
            if ($processCwd && $processCwd !== $this->currentDir) {
                // Permitir subdiret√≥rios (como manage/)
                if (!str_starts_with($processCwd, $this->currentDir)) {
                    return false;
                }
            }
        }

        return true;
    }

    private function isScreenSessionValid(int $pid, string $sessionName, string $scriptName): bool
    {
        if (!posix_kill($pid, 0)) {
            return false; // Processo screen n√£o existe
        }

        // Verificar se a sess√£o screen existe
        $screenList = shell_exec('screen -list');
        if (!$screenList || !str_contains($screenList, $sessionName)) {
            return false;
        }

        // Verificar se dentro da sess√£o screen h√° o processo PHP rodando nosso script
        $screenCommand = sprintf('screen -S %s -X hardcopy /tmp/screen_check_%s.tmp && sleep 0.1', 
            escapeshellarg($sessionName), 
            escapeshellarg($sessionName)
        );
        shell_exec($screenCommand);

        $tempFile = "/tmp/screen_check_{$sessionName}.tmp";
        if (file_exists($tempFile)) {
            $content = file_get_contents($tempFile);
            unlink($tempFile);

            $scriptBasename = basename($scriptName);
            return str_contains($content, $scriptBasename) || str_contains($content, 'php');
        }

        return true; // Se n√£o conseguir verificar o conte√∫do, assume que √© v√°lido
    }

    public function isPortInUse(int $port): bool
    {
        // Verificar TCP
        $tcpCommand = "netstat -tlnp 2>/dev/null | grep :{$port}";
        $tcpOutput = shell_exec($tcpCommand);

        // Verificar UDP
        $udpCommand = "netstat -ulnp 2>/dev/null | grep :{$port}";
        $udpOutput = shell_exec($udpCommand);

        return !empty(trim($tcpOutput??'')) || !empty(trim($udpOutput??''));
    }

    public function getProcessesUsingPort(int $port): array
    {
        $processes = [];

        // Buscar processos TCP
        $tcpCommand = "netstat -tlnp 2>/dev/null | grep :{$port}";
        $tcpOutput = shell_exec($tcpCommand);
        if ($tcpOutput) {
            $processes = array_merge($processes, $this->parseNetstatOutput($tcpOutput));
        }

        // Buscar processos UDP
        $udpCommand = "netstat -ulnp 2>/dev/null | grep :{$port}";
        $udpOutput = shell_exec($udpCommand);
        if ($udpOutput) {
            $processes = array_merge($processes, $this->parseNetstatOutput($udpOutput));
        }

        // Usar lsof como alternativa se netstat n√£o funcionar
        if (empty($processes)) {
            $lsofCommand = "lsof -ti:{$port} 2>/dev/null";
            $lsofOutput = shell_exec($lsofCommand);
            if ($lsofOutput) {
                $pids = array_filter(array_map('trim', explode("\n", $lsofOutput)));
                foreach ($pids as $pid) {
                    if (is_numeric($pid)) {
                        $processes[] = (int)$pid;
                    }
                }
            }
        }

        return array_unique($processes);
    }

    private function parseNetstatOutput(string $output): array
    {
        $pids = [];
        $lines = explode("\n", $output);

        foreach ($lines as $line) {
            if (preg_match('/(\d+)\//', $line, $matches)) {
                $pids[] = (int)$matches[1];
            }
        }

        return $pids;
    }

    public function killPort(int $port): bool
    {
        echo "üîå Liberando porta {$port}...\n";

        $processes = $this->getProcessesUsingPort($port);

        if (empty($processes)) {
            echo "‚ö†Ô∏è  Nenhum processo encontrado usando a porta {$port}\n";
            return true;
        }

        $killed = 0;
        shell_exec("killport {$port}");
        foreach ($processes as $pid) {
            echo "üíÄ Matando processo {$pid} que usa a porta {$port}...\n";


            // SIGTERM primeiro
            if (posix_kill($pid, SIGTERM)) {
                sleep(2);

                // Verificar se parou
                if (!posix_kill($pid, 0)) {
                    echo "‚úÖ Processo {$pid} finalizado graciosamente\n";
                    $killed++;
                    continue;
                }
            }

            // SIGKILL se necess√°rio
            if (posix_kill($pid, SIGKILL)) {
                sleep(1);

                if (!posix_kill($pid, 0)) {
                    echo "‚úÖ Processo {$pid} for√ßado a parar\n";
                    $killed++;
                } else {
                    echo "‚ùå Falha ao matar processo {$pid}\n";
                }
            }
        }

        // Verificar se a porta foi liberada
        sleep(1);
        if (!$this->isPortInUse($port)) {
            echo "‚úÖ Porta {$port} liberada com sucesso!\n";
            return true;
        } else {
            echo "‚ùå Porta {$port} ainda est√° em uso\n";
            return false;
        }
    }

    private function resolveFilesToBackup(): array
    {
        $files = [];

        foreach ($this->config['files_to_backup'] as $pattern) {
            if (strpos($pattern, '*') !== false) {
                $files = array_merge($files, glob($pattern));
            } else {
                $files[] = $pattern;
            }
        }

        return array_unique($files);
    }

    private function shouldExcludeFile(string $file): bool
    {
        foreach ($this->config['exclude_patterns'] as $pattern) {
            if (fnmatch($pattern, $file)) {
                return true;
            }
        }
        return false;
    }

    private function fileNotChanged(string $file): bool
    {
        $latestVersion = $this->getLatestVersion();
        if (!$latestVersion) return false;

        $currentPath = $this->currentDir . '/' . $file;
        $lastBackupPath = $this->baseBackupDir . '/v_' . $latestVersion . '/' . $file;

        if (!file_exists($lastBackupPath)) return false;

        return filemtime($currentPath) === filemtime($lastBackupPath) &&
                filesize($currentPath) === filesize($lastBackupPath);
    }

    private function createSymlink(string $file, string $backupPath): void
    {
        $latestVersion = $this->getLatestVersion();
        $sourcePath = $this->baseBackupDir . '/v_' . $latestVersion . '/' . $file;

        if (file_exists($sourcePath)) {
            symlink($sourcePath, $backupPath);
        }
    }

    private function compressBackup(string $versionDir): bool
    {
        $archivePath = $versionDir . '.tar.gz';
        $command = "tar -czf {$archivePath} -C " . dirname($versionDir) . " " . basename($versionDir) . " 2>&1";

        $output = shell_exec($command);

        // Verificar se o arquivo foi criado com sucesso
        if (file_exists($archivePath) && filesize($archivePath) > 0) {
            $this->removeDirectory($versionDir);
            echo "üì¶ Backup comprimido: " . basename($archivePath) . "\n";
            return true;
        } else {
            if ($output) {
                echo "‚ùå Erro na compress√£o: " . trim($output) . "\n";
            }
            return false;
        }
    }

    private function getAllVersions(): array
    {
        if (!is_dir($this->baseBackupDir)) return [];

        $versions = [];
        $dirs = scandir($this->baseBackupDir);

        foreach ($dirs as $dir) {
            if (strpos($dir, 'v_') === 0) {
                $versions[] = substr($dir, 2);
            }
        }

        rsort($versions);
        return $versions;
    }

    private function getLatestVersion(): ?string
    {
        $versions = $this->getAllVersions();
        return $versions[0] ?? null;
    }

    private function getFilesFromVersion(string $versionDir): array
    {
        $files = [];
        $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($versionDir)
        );

        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $relativePath = str_replace($versionDir . '/', '', $file->getPathname());
                if (!str_contains($relativePath, 'version_info.json')) {
                    $files[] = $relativePath;
                }
            }
        }

        return $files;
    }

    private function cleanupOldBackups(): void
    {
        $versions = $this->getAllVersions();
        $maxVersions = $this->config['max_versions'];

        if (count($versions) > $maxVersions) {
            $toDelete = array_slice($versions, $maxVersions);

            echo "üßπ Limpando backups antigos...\n";
            foreach ($toDelete as $version) {
                $this->deleteVersion($version);
            }
        }
    }

    private function createBackupDirectory(string $dir): bool
    {
        if (!is_dir($dir)) {
            $parentDir = dirname($dir);

            // Verificar se o diret√≥rio pai existe e √© acess√≠vel
            if (!is_dir($parentDir)) {
                echo "‚ùå Diret√≥rio pai n√£o existe: {$parentDir}\n";
                echo "üí° Certifique-se de que voc√™ tem permiss√µes na pasta superior\n";
                return false;
            }

            if (!is_writable($parentDir)) {
                echo "‚ùå Sem permiss√£o de escrita em: {$parentDir}\n";
                echo "üí° Execute: sudo chown -R \$USER {$parentDir}\n";
                return false;
            }

            if (!mkdir($dir, 0755, true)) {
                echo "‚ùå Erro ao criar diret√≥rio de backup: {$dir}\n";
                echo "üí° Verifique as permiss√µes do sistema de arquivos\n";
                return false;
            }

            echo "üìÅ Diret√≥rio de backup criado: {$dir}\n";
        }

        // Verificar se o diret√≥rio √© acess√≠vel
        if (!is_writable($dir)) {
            echo "‚ùå Diret√≥rio de backup n√£o √© acess√≠vel para escrita: {$dir}\n";
            echo "üí° Execute: sudo chown -R \$USER {$dir}\n";
            return false;
        }

        return true;
    }

    private function createVersionInfo(string $version, int $backedUpFiles, int $totalFiles, int $skippedFiles, int $totalSize): void
    {
        $info = [
                'version' => $version,
                'timestamp' => date('Y-m-d H:i:s'),
                'files_backed_up' => $backedUpFiles,
                'total_files' => $totalFiles,
                'skipped_files' => $skippedFiles,
                'total_size' => $totalSize,
                'source_directory' => $this->currentDir,
                'config_snapshot' => $this->config
        ];

        $versionDir = $this->baseBackupDir . '/v_' . $version;
        file_put_contents(
                $versionDir . '/version_info.json',
                json_encode($info, JSON_PRETTY_PRINT)
        );
    }

    private function removeDirectory(string $dir): bool
    {
        if (!is_dir($dir)) return false;

        $files = array_diff(scandir($dir), ['.', '..']);

        foreach ($files as $file) {
            $path = $dir . '/' . $file;
            is_dir($path) ? $this->removeDirectory($path) : unlink($path);
        }

        return rmdir($dir);
    }

    private function log(string $message): void
    {
        $timestamp = date('Y-m-d H:i:s');
        $logEntry = "[{$timestamp}] {$message}\n";
        file_put_contents($this->logFile, $logEntry, FILE_APPEND);
    }

    private function sendNotification(string $title, string $message): void
    {
        if (!$this->config['notifications']['enabled']) return;

        // Implementar notifica√ß√µes por email/webhook se configurado
        $this->log("Notifica√ß√£o: {$title} - {$message}");
    }

    public function showHelp(): void
    {
        echo "üîß Sistema Avan√ßado de Backup e Gerenciamento de Servi√ßos\n";
        echo "Uso: php backup.php [comando] [op√ß√µes]\n\n";

        $projectName = basename($this->currentDir);
        echo "üìÅ LOCALIZA√á√ÉO DOS BACKUPS:\n";
        echo "   Projeto: {$this->currentDir}\n";
        echo "   Backups: {$this->baseBackupDir}\n";
        echo "   üõ°Ô∏è  Os backups ficam FORA do projeto para seguran√ßa!\n\n";

        echo "üì¶ COMANDOS DE BACKUP:\n";
        echo "  save [vers√£o]          - Criar backup versionado\n";
        echo "  restore [vers√£o]       - Restaurar vers√£o espec√≠fica (√∫ltima se n√£o especificada)\n";
        echo "  list                   - Listar todas as vers√µes de backup\n";
        echo "  delete <vers√£o>        - Remover vers√£o espec√≠fica\n";
        echo "  status                 - Status atual dos backups\n\n";

        echo "üîß COMANDOS DE SERVI√áOS:\n";
        echo "  start <servi√ßo>        - Iniciar servi√ßo espec√≠fico\n";
        echo "  stop <servi√ßo>         - Parar servi√ßo (SIGTERM + SIGKILL se necess√°rio)\n";
        echo "  force-stop <servi√ßo>   - Parar servi√ßo for√ßadamente\n";
        echo "  restart <servi√ßo>      - Reiniciar servi√ßo espec√≠fico\n";
        echo "  start-all              - Iniciar todos os servi√ßos\n";
        echo "  stop-all               - Parar todos os servi√ßos\n";
        echo "  services               - Status de todos os servi√ßos\n";
        echo "  killport <porta>       - Matar processos que usam a porta\n";
        echo "  diagnose [servi√ßo]     - Diagnosticar problemas de servi√ßo\n";
        echo "  killall                - Matar TODOS os processos PHP (cuidado!)\n\n";

        echo "üîß SERVI√áOS DISPON√çVEIS:\n";
        foreach ($this->services as $name => $service) {
            echo "  {$name}                - {$service['name']}\n";
        }

        echo "\nüìã OUTROS COMANDOS:\n";
        echo "  help                   - Mostrar esta ajuda\n";
        echo "  config                 - Mostrar configura√ß√£o atual\n";
        echo "  check                  - Verificar integridade do sistema\n\n";

        echo "üí° EXEMPLOS:\n";
        echo "  php backup.php save                    # Backup com timestamp autom√°tico\n";
        echo "  php backup.php save producao_v1.0      # Backup com nome personalizado\n";
        echo "  php backup.php restore 2024-01-15_10-30-45  # Restaurar vers√£o espec√≠fica\n";
        echo "  php backup.php start liga              # Iniciar servi√ßo de liga√ß√µes\n";
        echo "  php backup.php stop server             # Parar servidor (graceful + force)\n";
        echo "  php backup.php killport 9501           # Liberar porta 9501\n";
        echo "  php backup.php force-stop runner       # For√ßar parada do runner\n";
        echo "  php backup.php stop-all                # Parar todos os servi√ßos\n";
    }

    public function showStatus(): void
    {
        echo "üìä STATUS GERAL DO SISTEMA\n\n";

        // Status dos backups
        echo "üì¶ BACKUPS:\n";
        echo "Diret√≥rio base (EXTERNO): {$this->baseBackupDir}\n";
        echo "Projeto de origem: {$this->currentDir}\n";

        // Verificar se o diret√≥rio de backup existe e √© acess√≠vel
        if (!is_dir($this->baseBackupDir)) {
            echo "‚ö†Ô∏è  Diret√≥rio de backup n√£o existe!\n";
        } elseif (!is_writable($this->baseBackupDir)) {
            echo "‚ö†Ô∏è  Diret√≥rio de backup sem permiss√£o de escrita!\n";
        } else {
            echo "‚úÖ Diret√≥rio de backup acess√≠vel\n";
        }

        $versions = $this->getAllVersions();
        $totalVersions = count($versions);
        $latestVersion = $versions[0] ?? 'Nenhuma';

        echo "Total de vers√µes: {$totalVersions}\n";
        echo "Vers√£o mais recente: v_{$latestVersion}\n";
        echo "Limite de vers√µes: {$this->config['max_versions']}\n\n";

        // Status dos servi√ßos
        echo "üîß SERVI√áOS:\n";
        $runningServices = 0;
        foreach ($this->services as $name => $service) {
            if ($this->isServiceRunning($name)) $runningServices++;
        }

        echo "Servi√ßos executando: {$runningServices}/" . count($this->services) . "\n\n";

        $this->showServicesStatus();

        // √öltimos logs
        echo "üìã √öLTIMOS LOGS:\n";
        if (file_exists($this->logFile)) {
            $logs = explode("\n", file_get_contents($this->logFile));
            $recentLogs = array_slice($logs, -5, 5);
            foreach ($recentLogs as $log) {
                if (trim($log)) echo "  {$log}\n";
            }
        } else {
            echo "  Nenhum log encontrado.\n";
        }
    }

    public function showConfig(): void
    {
        echo "‚öôÔ∏è  CONFIGURA√á√ÉO ATUAL:\n\n";
        echo json_encode($this->config, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE) . "\n";
    }

    public function checkBackupIntegrity(): void
    {
        echo "üîç Verifica√ß√£o de Integridade do Sistema de Backup\n\n";

        $projectName = basename($this->currentDir);
        $parentDir = dirname($this->currentDir);

        echo "üìä INFORMA√á√ïES DO SISTEMA:\n";
        echo "Projeto atual: {$this->currentDir}\n";
        echo "Pasta pai: {$parentDir}\n";
        echo "Nome do projeto: {$projectName}\n";
        echo "Diret√≥rio de backup: {$this->baseBackupDir}\n\n";

        echo "üîí VERIFICA√á√ïES DE SEGURAN√áA:\n";

        // 1. Verificar se backup n√£o est√° dentro do projeto
        if (str_starts_with($this->baseBackupDir, $this->currentDir)) {
            echo "‚ùå ERRO CR√çTICO: Backup dentro do projeto!\n";
            echo "   Se o projeto for exclu√≠do, os backups ser√£o perdidos!\n";
        } else {
            echo "‚úÖ Backup fora do projeto (seguro)\n";
        }

        // 2. Verificar permiss√µes
        if (is_dir($this->baseBackupDir)) {
            if (is_writable($this->baseBackupDir)) {
                echo "‚úÖ Diret√≥rio de backup acess√≠vel\n";
            } else {
                echo "‚ùå Sem permiss√£o de escrita no diret√≥rio de backup\n";
            }
        } else {
            echo "‚ö†Ô∏è  Diret√≥rio de backup n√£o existe (ser√° criado no primeiro backup)\n";
        }

        // 3. Verificar espa√ßo em disco
        if (is_dir($parentDir)) {
            $freeBytes = disk_free_space($parentDir);
            $totalBytes = disk_total_space($parentDir);

            if ($freeBytes !== false && $totalBytes !== false) {
                $freeGB = round($freeBytes / (1024 * 1024 * 1024), 2);
                $totalGB = round($totalBytes / (1024 * 1024 * 1024), 2);
                $usedPercent = round((($totalBytes - $freeBytes) / $totalBytes) * 100, 1);

                echo "üíæ Espa√ßo em disco:\n";
                echo "   Livre: {$freeGB} GB\n";
                echo "   Total: {$totalGB} GB\n";
                echo "   Uso: {$usedPercent}%\n";

                if ($freeGB < 1) {
                    echo "‚ö†Ô∏è  Pouco espa√ßo livre (<1GB)\n";
                } elseif ($usedPercent > 90) {
                    echo "‚ö†Ô∏è  Disco quase cheio (>{$usedPercent}%)\n";
                } else {
                    echo "‚úÖ Espa√ßo adequado\n";
                }
            }
        }

        // 4. Listar backups existentes
        echo "\nüìã BACKUPS EXISTENTES:\n";
        $versions = $this->getAllVersions();
        if (!empty($versions)) {
            echo "Total: " . count($versions) . " vers√µes\n";
            echo "Mais recente: v_" . $versions[0] . "\n";
            echo "Mais antiga: v_" . end($versions) . "\n";
        } else {
            echo "Nenhum backup encontrado\n";
        }

        echo "\nüí° RECOMENDA√á√ïES:\n";
        echo "‚Ä¢ Sempre mantenha os backups fora do projeto\n";
        echo "‚Ä¢ Fa√ßa backups regulares usando cron\n";
        echo "‚Ä¢ Verifique periodicamente o espa√ßo em disco\n";
        echo "‚Ä¢ Teste a restaura√ß√£o ocasionalmente\n";
    }
}

// Execu√ß√£o do script
if ($argc < 2) {
    echo "‚ùå Comando n√£o especificado!\n\n";
    $backup = new AdvancedBackupManager();
    $backup->showHelp();
    exit(1);
}

$command = $argv[1];
$option = $argv[2] ?? null;

$backup = new AdvancedBackupManager();

switch ($command) {
    case 'save':
        $success = $backup->save($option);
        exit($success ? 0 : 1);

    case 'restore':
        $success = $backup->restore($option);
        exit($success ? 0 : 1);

    case 'list':
        $backup->listVersions();
        exit(0);

    case 'delete':
        if (!$option) {
            echo "‚ùå Especifique a vers√£o a ser removida!\n";
            exit(1);
        }
        $success = $backup->deleteVersion($option);
        exit($success ? 0 : 1);

    case 'start':
        if (!$option) {
            echo "‚ùå Especifique o servi√ßo a ser iniciado!\n";
            exit(1);
        }
        $success = $backup->startService($option);
        exit($success ? 0 : 1);

    case 'stop':
        if (!$option) {
            echo "‚ùå Especifique o servi√ßo a ser parado!\n";
            exit(1);
        }
        $success = $backup->stopService($option);
        exit($success ? 0 : 1);

    case 'restart':
        if (!$option) {
            echo "‚ùå Especifique o servi√ßo a ser reiniciado!\n";
            exit(1);
        }
        $success = $backup->restartService($option);
        exit($success ? 0 : 1);

    case 'start-all':
        $backup->startAllServices();
        exit(0);

    case 'stop-all':
        $backup->stopAllServices();
        exit(0);

    case 'services':
        $backup->showServicesStatus();
        exit(0);

    case 'killport':
        if (!$option || !is_numeric($option)) {
            echo "‚ùå Especifique a porta a ser liberada!\n";
            echo "üí° Uso: php backup.php killport 9501\n";
            exit(1);
        }
        $success = $backup->killPort((int)$option);
        exit($success ? 0 : 1);

    case 'force-stop':
        if (!$option) {
            echo "‚ùå Especifique o servi√ßo a ser parado for√ßadamente!\n";
            exit(1);
        }
        echo "üíÄ Parando servi√ßo for√ßadamente: {$option}\n";
        $success = $backup->stopService($option);
        exit($success ? 0 : 1);

    case 'diagnose':
        if ($option) {
            // Diagn√≥stico de servi√ßo espec√≠fico
            if (!isset($backup->services[$option])) {
                echo "‚ùå Servi√ßo n√£o encontrado: {$option}\n";
                exit(1);
            }

            $service = $backup->services[$option];
            echo "üîç Diagn√≥stico do servi√ßo: {$service['name']}\n\n";

            // Verificar script
            echo "üìÑ Script: {$service['script']}\n";
            echo "   Existe: " . (file_exists($service['script']) ? "‚úÖ" : "‚ùå") . "\n";

            // Verificar arquivo PID
            echo "üìç Arquivo PID: {$service['pid_file']}\n";
            if (file_exists($service['pid_file'])) {
                $pidContent = trim(file_get_contents($service['pid_file']));
                echo "   Conte√∫do: {$pidContent}\n";
                if (is_numeric($pidContent)) {
                    $pid = (int)$pidContent;
                    echo "   Processo existe: " . (posix_kill($pid, 0) ? "‚úÖ" : "‚ùå") . "\n";
                    if (posix_kill($pid, 0)) {
                        echo "   √â nosso processo: " . ($backup->isOurProcess($pid, $service['script']) ? "‚úÖ" : "‚ùå") . "\n";
                    }
                }
            } else {
                echo "   Existe: ‚ùå\n";
            }

            // Verificar porta
            if (isset($service['port'])) {
                echo "üîå Porta: {$service['port']}\n";
                echo "   Em uso: " . ($backup->isPortInUse($service['port']) ? "‚úÖ" : "‚ùå") . "\n";
                $processes = $backup->getProcessesUsingPort($service['port']);
                if (!empty($processes)) {
                    echo "   Processos usando a porta: " . implode(', ', $processes) . "\n";
                }
            }

            // Buscar processos
            echo "üîç Busca de processos:\n";
            $pids = $backup->findProcessesByScript($service['script']);
            if (!empty($pids)) {
                echo "   Processos encontrados: " . implode(', ', $pids) . "\n";
                foreach ($pids as $pid) {
                    echo "   PID {$pid} √© nosso: " . ($backup->isOurProcess($pid, $service['script']) ? "‚úÖ" : "‚ùå") . "\n";
                }
            } else {
                echo "   Nenhum processo encontrado\n";
            }

        } else {
            // Diagn√≥stico geral
            echo "üîç Diagn√≥stico Geral do Sistema\n\n";
            echo "üìä Resumo de Processos PHP:\n";
            $allPhpProcesses = shell_exec("ps aux | grep -v grep");
            if ($allPhpProcesses) {
                $lines = explode("\n", trim($allPhpProcesses));
                echo "Total: " . count($lines) . " processos\n\n";
                foreach ($lines as $line) {
                    if (trim($line)) {
                        echo "  " . substr($line, 0, 200) . "\n";
                    }
                }
            }
        }
        exit(0);

    case 'killall':
        echo "üíÄ Matando todos os processos PHP...\n";
        echo "‚ö†Ô∏è  ATEN√á√ÉO: Isso vai parar TODOS os processos PHP!\n";
        echo "Digite 'sim' para confirmar: ";
        $handle = fopen("php://stdin", "r");
        $confirmation = trim(fgets($handle));
        fclose($handle);

        if (strtolower($confirmation) === 'sim') {
            shell_exec('killall -9 php 2>/dev/null');
            echo "‚úÖ Todos os processos PHP foram finalizados\n";
            exit(0);
        } else {
            echo "‚ùå Opera√ß√£o cancelada\n";
            exit(1);
        }

    case 'status':
        $backup->showStatus();
        exit(0);

    case 'config':
        $backup->showConfig();
        exit(0);

    case 'check':
    case 'integrity':
        $backup->checkBackupIntegrity();
        exit(0);

    case 'help':
    case '--help':
    case '-h':
        $backup->showHelp();
        exit(0);

    default:
        echo "‚ùå Comando inv√°lido: {$command}\n\n";
        $backup->showHelp();
        exit(1);
}
